pruebas linea [300] 
uint32_t d = (uint32_t) *buffer; // 4 * 8 = 32
        // este d probablemente falle [si es siempre 0] 

        // printf("%u %u %u %u \n IMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTE [%d], [%d]\n",buffer[0], buffer[1],buffer[2], buffer[3], (int) b, (int) d);
        // b esta malo ojo

// dice se escribieron 724.992 o 354 bloques? porque se detuvo?
// 8.896.512
// OJO DICE QUE SE ESCRIBEN MAS PERO ES PORQUE LE PIDO QUE ESCRIBA un poco mas 
// 8.894.818 de bytes pesa el libro o 8.9MB

Un archivo comienza a usar dir indirecto a los:
     1.024.000 bits = 500*2048
y tiene un maximo de tamanho de:
    11.509.760 bits = 1024000+((10×512)×2048)
    # es decir 11.5 MB ???

11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 
11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 
11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 
11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 
11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 
11111111 11111111 11111111 11111111

44 bloques

FILE* f_new = fopen("ex1_same.txt", "wb"); // Escritura binaria.
fwrite(buffer, 1, size_f, f_new); 
// Escribimos la misma cantidad de bytes desde el buffer.
fclose(f_new);

// uint32_t num =  (uint32_t)buffer[0] << 24 |
//                 (uint32_t)buffer[1] << 16 |
//                 (uint32_t)buffer[2] << 8  |
//                 (uint32_t)buffer[3];
// printf("Valor de B: %u | num: %u\n", b, num);

cant de bytes max a medida que escribamos le vamos restando
si aun quedan entoces listo
probar con .gif
hay punteros que solo usan con bloques de dir directo
si se usan de dir indirecto son archivos grandes

Es importante destacar que la lectura y escritura de Byte en los bloques de 
datos deben ser realizadas en orden big endian


Si se escribe un archivo y ya no queda espacio disponible en el disco virtual, 
debe terminar la escritura y dar aviso de que ésta no fue realizada en su 
totalidad mediante un mensaje de error en stderr 1 . No debe eliminar el 
archivo que estaba siendo escrito.
Dada la estructura de los bloques ı́ndice, sus archivos tendrán un tamaño 
máximo. Si está escribiendo un archivo y éste supera ese tamaño máximo, no debe 
eliminar el archivo, sino que debe dejar almacenado el máximo de datos posible 
y retornar el valor apropiado desde cr write.

se cree una entrada en el directorio y el bloque índice correspondiente al 
hacer cr_open


  //a = (b==0) ? 1 : 0;
  //a will have the value 1 if b is equal to 0, and 0 otherwise.
  // label:
  //    bla bla
  // goto label; makes a jump to label


bloque indice [primer bloque de un archivo] -> (500 punteros) bloques de datos
                                            -> (10  punteros) bloques de dir ind

bloque de dir ind -> (solo punteros) bloques de datos

despues de 32
for (int j = 0; j < 4; j++){
            uint8_t b = (uint8_t) buffer[j];
            }
unsigned array to uint 32

num = (uint32_t)buffer[0] << 24 |
      (uint32_t)buffer[1] << 16 |
      (uint32_t)buffer[2] << 8  |
      (uint32_t)buffer[3];

// printf("%d\n", 4096%2048);
// printf("%d\n", 0%2048); 
// printf("%d\n", 4095%2048); 
// printf("%d\n", 2%2048); 

// pointer to current writing | reading pos
int p_pos; ir actualizando

// pointer to index block
int p_index; 

funcion actualizar bloque escribo hasta que completo un bloque
luego llamo a actualizar bloque y me dice donde hay un bloque en el que puedo
escribir OJO este puede ser directo o indirecto yo solo escribo
actualizar bloque actualiza tambien el index block con el puntero al nuevo bloque



Función para escribir archivos. Escribe en el archivo descrito por file_desc 
los nbytes que se encuentren en la dirección indicada por buffer. Retorna la
cantidad de Byte escritos en el archivo. Si se produjo un error porque no pudo 
seguir escribiendo, ya sea porque el disco se llenó o porque el archivo no 
puede crecer más, este número puede ser menor a nbytes (incluso 0).


Bloque ı́ndice. Un bloque ı́ndice es el primer bloque de un archivo y contiene 
la información necesaria para acceder al contenido del archivo. Está compuesto 
por:
    4 Bytes al inicio del bloque para el tamaño del archivo.
    
    4 Bytes para contar la cantidad de hardlinks que apuntan al archivo.
    
    2000 Byte. Espacio para 500 punteros. Cada uno apunta a un bloque de datos.
    
    40 Bytes al final del bloque, almacenan hasta diez punteros a bloques de 
    direccionamiento indirecto.

Cuando se escribe un archivo, se escribe en los bloques apuntados por los 
punteros directos. Una vez que estos se han llenado, se empieza a usar el 
bloque de direccionamiento indirecto.

Bloque de direccionamiento indirecto. Un bloque de direccionamiento indirecto 
utiliza todo su espacio para almacenar punteros a bloques de datos.

Bloque de datos. Un bloque de datos utiliza todo su espacio para almacenar el 
contenido (datos) de un archivo. El formato de este bloque depende 
exclusivamente de lo que se quiere guardar en el archivo. Una vez que un bloque
ha sido asignado a un archivo, se asigna de manera completa. Es decir, si el 
archivo requiere menos espacio que el tamaño del bloque, el espacio no 
utilizado sigue siendo parte del bloque (aunque no sea parte del archivo) y no 
puede ser subasignado a otro archivo.


FILE* f = fopen(path_disk, "rb" );
unsigned char *buffer_bytes = malloc( sizeof(unsigned char) * size_f );
// leo desde donde diga buffer (va a ser tipo 2048 para leer el 2 bloque)
// pero leo de 32 bits luego tiene que    
// int b = buffer/size_f;
// for( int i = b; i < b+(2048/size_f); i++ ) {    
//     fseek( f, size_f * i, SEEK_SET );
//     fread( buffer_bytes, sizeof( unsigned char ), size_f, f );
//     }
fclose(f);
void* buffer_m = "hola esta es una prueba";
void* buffer_n = fopen("~/Music/Amen.mp3", "rb" );
FILE* f_new = fopen(path_disk, "wb");
fwrite(buffer_bytes, 1, size_f, f_new);
fclose(f_new);
  
free( buffer_bytes );


// ----------------------------------------------------
crFILE* file_desc = cr_open(/path/a/escrivir.p, 'w');

void* buffer = "hola esta es una prueba";

cr_write(file_desc, buffer, 24);
// ----------------------------------------------------
crFILE* file_desc = cr_open(/path/a/escrivir.p, 'w');

void* buffer = fopen("~/Music/musica.mp3", "rb" );

cr_write(file_desc, buffer, 1048576);

// ----------------------------------------------------

Ejemplo de germy


cr_read(f, buffer, 2048); // Lo lleno con 2KB.
// Con el método anterior llené el contenido desde la posición 0 a la 2047. 
// Ahora, paso el puntero de la posición 2048 para que parta desde ahí.
cr_read(f,&buffer[2048],2048); 

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////// ANTIGUAS VERSIONES //////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

THIS WORK PERFECTLY
int cr_write(crFILE* file_desc, void* buffer, int nbytes){
    printf("bytes rest: %d\n", nbytes);
    printf("Pointer:    %p\n", &buffer);
    unsigned char *p =(unsigned char *) buffer;
    int written = 0;
    int size_f = 1;  // amount of bytes to be wroten in each iteration
    int bytes_rest = nbytes;  // bytes restantes
    
    if (!file_desc->mode){
        fprintf( stderr, "Error: operation not allowed\n");
        return 0;}
    
    // primer paso guardar en un buffer los bytes leidos    
    for (int i = 0; i < size_f; i++){
        // p[i];  // es un byte
        printf("%c\n", ((char *) p) [i]);
        written++;
        bytes_rest --;
    }

    if (bytes_rest > 0){
        written += cr_write(file_desc, &p[written], bytes_rest);
    }
    

    // antes de devolver a written tengo que actualizar en bloque indice
    // los bytes escritos en sus bloques almacenados
    return written;
}
////////////////////////////////////////////////////////////////////////////////
#include "file_mang_func.h"

extern char path_disk[400];

int global_written = 0;
int block_written  = 0; // indica cuantos he escrito en el
// bloque actual


const char *bit_rep_3[16] = {
    [ 0] = "0000", [ 1] = "0001", [ 2] = "0010", [ 3] = "0011",
    [ 4] = "0100", [ 5] = "0101", [ 6] = "0110", [ 7] = "0111",
    [ 8] = "1000", [ 9] = "1001", [10] = "1010", [11] = "1011",
    [12] = "1100", [13] = "1101", [14] = "1110", [15] = "1111",
};

int byte_pos(uint8_t byte){
    char linea[8];
    sprintf(linea, "%s%s", bit_rep_3[byte >> 4], bit_rep_3[byte & 0x0F]);

    for (int i = 0; i < 8; i++){
        if( linea[i] == '0'){
            return i;
        }
    }
    return 9;  // 9 marca que no encontro
}

int search_free_space(){
    // busca un bloque libre para transformarlo en uno de datos
    // tengo que actualizar el bitmap cuando creo
    // el bloque de datos
    FILE* f = fopen(path_disk, "rb" );
	unsigned char *buffer = malloc( sizeof(unsigned char) * 8 );
    // buffer de 8 Byte
	for( int i = 256; i < 1280; i++ ) {    
		fseek( f, 8 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 8, f );
        for (int j = 0; j < 8; j++){
            uint8_t b = (uint8_t) buffer[j];
            // tenemos 1 bytes es decir 8 bits
            // necesitamos saber si en esos 8 bits hay un 0
            // y si lo hay donde y cambiarlo por 1
            int pos = byte_pos(b);
            if (pos<9){
                int indice_bloque = i+pos;
                // ESCRIBIR actualizar bitmap
                
                return indice_bloque;  
                }
            }
        }
    return 0;
}

int actualizar_bloque(crFILE* file_desc){
    // se encarga de decirme donde hay un bloque para escribir
    // actualiza la info del index block
    // si no quedan bloques retorna 0

    // cada puntero es de 4 bytes
    FILE* f = fopen(path_disk, "rb" );    
	unsigned char *buffer = malloc( sizeof(unsigned char) * 4 );

    // buscamos un espacio para direccionar dentro del bloque indice
    // 2000 bytes
    int inicio = file_desc->p_index/4 + 8;
    // leo del bloque indice la parte de direccionamiento directo
	for( int i = inicio; i < inicio + 502; i++ ) {
		fseek( f, 4 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 4, f );
        
        uint32_t b   =  (uint32_t) *buffer; // 4 * 8 = 32
        if (b==0){
            printf("Hay espacio en direccionamiento directo\n");
            // debo buscar un bloque libre para que sea
            // el bloque de datos
            int indice_bloque = search_free_space();
            // en cr_write nos ocuparemos de actualizar los
            // bytes escritos en el bloque indice
            fclose(f);
            
            // ESCRIBIR el puntero a la dir encontrada en la parte de
            // direccionamiento directo
            // FILE* f = fopen(path_disk, "wb" );    
            // fseek( f, 4 * i, SEEK_SET ); //revisar si es -4 o esta bien
		    // fwrite( buffer, sizeof( unsigned char ), 4, f );
            // fclose(f);	        
            // printf("retorne [actualizar bloque] %d\n", (int) *buffer);
            // return (int) *buffer;

            printf("Indice Bloque: %d\n", indice_bloque);
            return indice_bloque;
        }
    };
    
    // 40 bytes de punteros a bloques de dir indirecto
    printf("probando con indirecto\n");
    for( int i = inicio + 502; i < inicio + 512; i++ ) { 
		fseek( f, 4 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 4, f );
        uint32_t b = (uint32_t) *buffer; // 4 * 8 = 32
        if (b){
            printf("buscando espacio dentro de bloque de direccionamiento indirecto\n");
            // si entre -> b es un puntero a un bloque de dir indirecto
            // debo revisar si este bloque tiene espacio para otro puntero
            // a un bloque de datos
            for( int j = (int) b; j < ((int)b) + 512; j++ ) {    
                fseek( f, 4 * j, SEEK_SET );
		        fread( buffer, sizeof( unsigned char ), 4, f );
                uint32_t c = (uint32_t) *buffer;
                if (c==0){
                    printf("hay espacio en este bloque de dir. indirecto\n");
                    // hay espacio para otro puntero de datos
                    int indice_bloque = search_free_space();
                    if (indice_bloque){
                        printf("hay espacio para nuevo bloque de datos\n");
                        // si encontre un lugar para un bloque de datos
                        // ESCRIBIR el puntero a la dir encontrada en el bloque
                        // de direccionamiento indirecto
                        printf("Indice Bloque: %d\n", indice_bloque);
                        fclose(f);
                        return indice_bloque;
                    }
                }
            }
        }
        
        else if (b==0){
            printf("Hay espacio para nuevo puntero a un bloque de direccionamiento indirecto\n");
            //ahora debemos buscar un espacio vacio para 
            //un bloque de dir indirecto guardar su direccion
            //luego buscar un espacio vacio para un bloque de datos que va a 
            //guardar su direccion en el nuevo bloque de dir indirecto
            int indice_bloque_indirect = search_free_space();
            // ESCRIBIR el puntero a la dir encontrada en la parte
            // de direccionamiento indirecto
            if (indice_bloque_indirect){
                printf("Hay espacio para nuevo bloque\n");
                for( int j = indice_bloque_indirect; j <indice_bloque_indirect\
                 +512; j++ ) {    
                    fseek( f, 4 * j, SEEK_SET );
                    fread( buffer, sizeof( unsigned char ), 4, f );
                    uint32_t c = (uint32_t) *buffer;
                    if (c==0){
                        printf("Hay espacio para nuevo puntero a datos\n");
                        // espacio para otro puntero de datos
                        int indice_bloque = search_free_space();
                        if (indice_bloque){
                            printf("Hay espacio para nuevo bloque de datos\n");
                            // si encontre un lugar para un bloque de datos
                            // ESCRIBIR el puntero a la dir encontrada en el bloque
                            // de direccionamiento indirecto
                            printf("Indice Bloque: %d\n", indice_bloque);
                            fclose(f);
                            return indice_bloque;
                        }
                    }
                }
            }
        }
	};
    // aqui hay un return una vez encuentra un bloque de
    // dir indirecto
    
    fclose(f);
	free( buffer );
    return 0;  // si no funciono nada -> se ha alcanzado el limite de archivo
}

int cr_write(crFILE* file_desc, void* buffer, int nbytes){
    printf("bytes rest: %d\n", nbytes);
    printf("Pointer:    %p\n", &buffer);
    unsigned char *p =(unsigned char *) buffer;
    int written = 0;
    int size_f = 8;  // amount of bytes to be wroten in each iteration
    int bytes_rest = nbytes;  // bytes restantes

    if (!file_desc->mode){
        fprintf( stderr, "Error: operation not allowed\n");
        return 0;}
    
    if (block_written%2048==0){
        file_desc->p_pos = actualizar_bloque(file_desc);
    }
    if (!file_desc->p_pos){
        printf("Error: disk full you can't write more\n");
        return written; // no se puede seguir escribiendo
    }
    
    for (int i = 0; i < size_f; i++){
        // p[i];  // es un byte
        // ESCRIBIR los bytes en la posicion dada
        printf("%c\n", ((char *) p) [i]);
        written++;
        block_written ++;
        bytes_rest --;
    }

    if (bytes_rest > 0){
        written += cr_write(file_desc, &p[written], bytes_rest);
    }

    // antes de devolver a written tengo que actualizar en bloque indice
    // los bytes escritos en sus bloques almacenados

    // ESCRIBIR los bytes escritos en el bloque indice
    return written;
}
////////////////////////////////////////////////////////////////////////////////
MEJORAS LUNES

#include "file_mang_func.h"

extern char path_disk[400];

int global_written = 0;
int block_written  = 0; // indica cuantos he escrito en el
// bloque actual


const char *bit_rep_3[16] = {
    [ 0] = "0000", [ 1] = "0001", [ 2] = "0010", [ 3] = "0011",
    [ 4] = "0100", [ 5] = "0101", [ 6] = "0110", [ 7] = "0111",
    [ 8] = "1000", [ 9] = "1001", [10] = "1010", [11] = "1011",
    [12] = "1100", [13] = "1101", [14] = "1110", [15] = "1111",
};

char* byte4_str(uint32_t byte4){
    char* linea = malloc(sizeof(char)* 32);
    sprintf(linea,"%s%s%s%s%s%s%s%s",\
    bit_rep_3[(byte4 >> 28) & 0x0000000F],\
    bit_rep_3[(byte4 >> 24) & 0x0000000F],\
    bit_rep_3[(byte4 >> 20) & 0x0000000F],\
    bit_rep_3[(byte4 >> 16) & 0x0000000F],\
    bit_rep_3[(byte4 >> 12) & 0x0000000F],\
    bit_rep_3[(byte4 >> 8) & 0x0000000F],\
    bit_rep_3[(byte4 >> 4) & 0x0000000F],\
    bit_rep_3[byte4 & 0x0000000F]);
    // 0x0F = 0000 1111
    // 0x0000000F = 0000 0000 0000 0000 0000 0000 0000 1111
    return linea;
}

// stackOverflow
// https://stackoverflow.com/questions/36793073/how-to-convert-from-a-binary-string-to-binary-unsigned-char
unsigned char stringToBinary(char tmpSubjectStatus[]){
    int tmpInteger = 0;
    while (*tmpSubjectStatus)
    {
        tmpInteger <<= 1;
        if (*tmpSubjectStatus == '1')
            tmpInteger += 1;
        tmpSubjectStatus++;
    }
    return (unsigned char) tmpInteger;
}

void escribir_4byte_from_int_2(int indice_bloque, int where){
    // 100000000000101 = 16389 usa 7 bits
    // 0100000000000101 -> 2 bytes
    // 00000000 00000000 01000000 00000101 
    // 00000000 00000000 01000000 00000101
    // where = 4 * i
    FILE* h = fopen(path_disk, "r+" );    
    fseek( h, where, SEEK_SET ); //revisar si es -4 o esta bien
    uint32_t b = (uint32_t) indice_bloque;
    // printf("EN uint32_t %u\n", b); // bien
    // escribir 4 bytes
    char* linea = malloc(32*sizeof(char));
    linea = byte4_str(b);
    printf("TRANSFORMADO A BIN: %s\n", linea); // perfecto
    
    char* linea1 = malloc(8*sizeof(char));
    char* linea2 = malloc(8*sizeof(char));
    char* linea3 = malloc(8*sizeof(char));
    char* linea4 = malloc(8*sizeof(char));

    sprintf(linea1, "%c%c%c%c%c%c%c%c", linea[0], linea[1], linea[2], linea[3], linea[4], linea[5], linea[6], linea[7]);
    sprintf(linea2, "%c%c%c%c%c%c%c%c", linea[8], linea[9], linea[10], linea[11], linea[12], linea[13], linea[14], linea[15]);
    sprintf(linea3, "%c%c%c%c%c%c%c%c", linea[16], linea[17], linea[18], linea[19], linea[20], linea[21], linea[22], linea[23]);
    sprintf(linea4, "%c%c%c%c%c%c%c%c", linea[24], linea[25], linea[26], linea[27], linea[28], linea[29], linea[30], linea[31]);

    // printf("LINEA1: %s\n", linea1); // perfecto
    // printf("LINEA2: %s\n", linea2); // perfecto
    // printf("LINEA3: %s\n", linea3); // perfecto
    // printf("LINEA4: %s\n", linea4); // perfecto                

    unsigned char byte1 = stringToBinary(linea1);
    unsigned char byte2 = stringToBinary(linea2);
    unsigned char byte3 = stringToBinary(linea3);
    unsigned char byte4 = stringToBinary(linea4);

    fputc( (int) byte1, h);
    fputc( (int) byte2, h);
    fputc( (int) byte3, h);
    fputc( (int) byte4, h);

    fclose(h);	 
}       

void escribir_4byte_from_int(int indice_bloque, int where){
    // 100000000000101 = 16389 usa 7 bits
    // 0100000000000101 -> 2 bytes
    // 00000000 00000000 01000000 00000101 
    // 00000000 00000000 01000000 00000101
    // where = 4 * i
    FILE* h = fopen(path_disk, "r+" );    
    fseek( h, where, SEEK_SET ); //revisar si es -4 o esta bien
    uint32_t b = (uint32_t) indice_bloque;
    // printf("EN uint32_t %u\n", b); // bien
    // escribir 4 bytes
    char* linea = malloc(32*sizeof(char));
    linea = byte4_str(b);
    // printf("TRANSFORMADO A BIN: %s\n", linea); // perfecto
    
    char* linea1 = malloc(8*sizeof(char));
    char* linea2 = malloc(8*sizeof(char));
    char* linea3 = malloc(8*sizeof(char));
    char* linea4 = malloc(8*sizeof(char));

    sprintf(linea1, "%c%c%c%c%c%c%c%c", linea[0], linea[1], linea[2], linea[3], linea[4], linea[5], linea[6], linea[7]);
    sprintf(linea2, "%c%c%c%c%c%c%c%c", linea[8], linea[9], linea[10], linea[11], linea[12], linea[13], linea[14], linea[15]);
    sprintf(linea3, "%c%c%c%c%c%c%c%c", linea[16], linea[17], linea[18], linea[19], linea[20], linea[21], linea[22], linea[23]);
    sprintf(linea4, "%c%c%c%c%c%c%c%c", linea[24], linea[25], linea[26], linea[27], linea[28], linea[29], linea[30], linea[31]);

    // printf("LINEA1: %s\n", linea1); // perfecto
    // printf("LINEA2: %s\n", linea2); // perfecto
    // printf("LINEA3: %s\n", linea3); // perfecto
    // printf("LINEA4: %s\n", linea4); // perfecto                

    unsigned char byte1 = stringToBinary(linea1);
    unsigned char byte2 = stringToBinary(linea2);
    unsigned char byte3 = stringToBinary(linea3);
    unsigned char byte4 = stringToBinary(linea4);

    fputc( (int) byte1, h);
    fputc( (int) byte2, h);
    fputc( (int) byte3, h);
    fputc( (int) byte4, h);

    fclose(h);	 
}       


int byte_pos(uint8_t byte){
    char linea[8];
    sprintf(linea, "%s%s", bit_rep_3[byte >> 4], bit_rep_3[byte & 0x0F]);

    for (int i = 0; i < 8; i++){
        if( linea[i] == '0'){
            return i;
        }
    }
    return 9;  // 9 marca que no encontro
}

char* change_bit_in_byte(uint8_t byte, int pos, char* linea){
    sprintf(linea, "%s%s", bit_rep_3[byte >> 4], bit_rep_3[byte & 0x0F]);
    linea[pos] = '1';
    return linea;
}

int search_free_space(){
    // busca un bloque libre para transformarlo en uno de datos
    // tengo que actualizar el bitmap cuando creo
    // el bloque de datos
    FILE* f = fopen(path_disk, "rb" );
	unsigned char *buffer = malloc( sizeof(unsigned char) * 8 );
    // buffer de 8 Byte
	for( int i = 256; i < 1280; i++ ) {    
		fseek( f, 8 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 8, f );
        for (int j = 0; j < 8; j++){
            uint8_t b = (uint8_t) buffer[j];
            // tenemos 1 bytes es decir 8 bits
            // necesitamos saber si en esos 8 bits hay un 0
            // y si lo hay donde y cambiarlo por 1
            int pos = byte_pos(b);
            if (pos<9){
                // no estoy muy seguro que el indice este bien
                fclose(f);
                // 256*8 = 2048 Bytes * 8 = bits

                // ESCRIBIR actualizar bitmap

                // FILE* h = fopen(path_disk, "wb" );
                // FILE* h = fopen(path_disk, "w+" );
                FILE* h = fopen(path_disk, "r+" );
                int posicion = 8*i+j;

                char* linea = malloc(8*sizeof(char));
                linea = change_bit_in_byte(b, pos, linea);
                unsigned char imp = stringToBinary(linea);

                // printf("VIEJA LINEA: %u\n", buffer[j]);
                // printf("NUEVA LINEA: %s\n", linea);
                // printf("NUEVA LINEA TRANSFORMADA: %u\n", imp);

                printf("POSICION %d\n", posicion);
                fseek( h, posicion, SEEK_SET );
                fputc( (int) imp, h);
                
                fclose(h);
                print_binary(2048/8, (2048+8)/8);
                
                // int indice_bloque = ((posicion*2048) + pos);
                // int indice_bloque = (((((i-256)*8)+j)*2048)+pos);
                // int indice_bloque = (((((i-256)*8)+j+pos)*2048));

                // printf("i:   %d\n",i);
                // printf("j:   %d\n",j);
                // printf("pos: %d\n",pos);
                int indice_bloque = (((((i-256+j)*8)+pos)*2048));

                // ESTA MAL TIENE QUE INDICAR BIEN EL NUMERO DEL BLOQUE LIBRE
                // indica el bloque ya usado por el bloque indice????
                return indice_bloque; // pos en bits  
                }
            }
        }
    return 0;
}

// desde 20480 a 22528
int actualizar_bloque(crFILE* file_desc){
    // se encarga de decirme donde hay un bloque para escribir
    // actualiza la info del index block
    // si no quedan bloques retorna 0

    // cada puntero es de 4 bytes
    FILE* f = fopen(path_disk, "rb" );    
	unsigned char *buffer = malloc( sizeof(unsigned char) * 4 );

    // buscamos un espacio para direccionar dentro del bloque indice
    // 2000 bytes
    int inicio = (file_desc->p_index/4) + 2;
    // leo del bloque indice la parte de direccionamiento directo
	for( int i = inicio; i < inicio + 500; i++ ) {
		fseek( f, 4 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 4, f );

        int es_cero = 1;
        for (int j = 0; j < 4; j++){
            uint8_t c = (uint8_t) buffer[j];
            if (c){
                es_cero=0;
            }
        }

        if (es_cero){
            printf("Hay espacio en direccionamiento directo\n");
            // debo buscar un bloque libre para que sea
            // el bloque de datos
            int indice_bloque = search_free_space();
            // en cr_write nos ocuparemos de actualizar los
            // bytes escritos en el bloque indice
            if (indice_bloque){
                printf("Hay espacio nuevo bloque de datos [%d]\n", 4 * i);    
                fclose(f);
                // ESCRIBIR el puntero a la dir encontrada en la parte de
                // direccionamiento directo
                printf("Indice Bloque: %d\n", indice_bloque);                
                escribir_4byte_from_int_2(indice_bloque, 4*i);       
                print_binary(((2048*40)-32)/8, ((2048*40)+150)/8);
                printf("I: %d\n", i*4);                                
                return indice_bloque;
            }
        }
    };
    
    // 40 bytes de punteros a bloques de dir indirecto
    printf("probando con indirecto\n");
    for( int i = inicio + 502; i < inicio + 512; i++ ) { 
		fseek( f, 4 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 4, f );

        int es_cero = 1;
        for (int j = 0; j < 4; j++){
            uint8_t c = (uint8_t) buffer[j];
            if (c){
                es_cero=0;
            }
        }
        uint32_t b = (uint32_t) *buffer; // 4 * 8 = 32
        // este b esta obviamente malo
        if (!es_cero){
            printf("buscando espacio dentro de bloque de direccionamiento indirecto\n");
            // si entre -> b es un puntero a un bloque de dir indirecto
            // debo revisar si este bloque tiene espacio para otro puntero
            // a un bloque de datos
            for( int j = (int) b; j < ((int)b) + 512; j++ ) {    
                fseek( f, 4 * j, SEEK_SET );
		        fread( buffer, sizeof( unsigned char ), 4, f );
                uint32_t c = (uint32_t) *buffer;
                if (c==0){
                    printf("hay espacio en este bloque de dir. indirecto\n");
                    // hay espacio para otro puntero de datos
                    int indice_bloque = search_free_space();
                    if (indice_bloque){
                        printf("hay espacio para nuevo bloque de datos\n");
                        // si encontre un lugar para un bloque de datos
                        // ESCRIBIR el puntero a la dir encontrada en el bloque
                        // de direccionamiento indirecto
                        printf("Indice Bloque: %d\n", indice_bloque);
                        fclose(f);
                        escribir_4byte_from_int(indice_bloque, 4*j);     
                        return indice_bloque;
                    }
                }
            }
        }
        
        else{
            printf("Hay espacio para nuevo puntero a un bloque de direccionamiento indirecto\n");
            //ahora debemos buscar un espacio vacio para 
            //un bloque de dir indirecto guardar su direccion
            //luego buscar un espacio vacio para un bloque de datos que va a 
            //guardar su direccion en el nuevo bloque de dir indirecto
            int indice_bloque_indirect = search_free_space();
            // ESCRIBIR el puntero a la dir encontrada en la parte
            // de direccionamiento indirecto
            if (indice_bloque_indirect){
                printf("Hay espacio para nuevo bloque\n");
                for( int j = indice_bloque_indirect; j<indice_bloque_indirect\
                 +512; j++ ) {    
                    fseek( f, 4 * j, SEEK_SET );
                    fread( buffer, sizeof( unsigned char ), 4, f );
                    uint32_t c = (uint32_t) *buffer;
                    if (c==0){
                        printf("Hay espacio para nuevo puntero a datos\n");
                        // espacio para otro puntero de datos
                        int indice_bloque = search_free_space();
                        if (indice_bloque){
                            printf("Hay espacio para nuevo bloque de datos\n");
                            // si encontre un lugar para un bloque de datos
                            // ESCRIBIR el puntero a la dir encontrada en el bloque
                            // de direccionamiento indirecto
                            printf("Indice Bloque: %d\n", indice_bloque);
                            fclose(f);
                            escribir_4byte_from_int(indice_bloque, 4*j);       
                            return indice_bloque;
                        }
                    }
                }
            }
        }
	};
    // aqui hay un return una vez encuentra un bloque de
    // dir indirecto
    
    fclose(f);
	free( buffer );
    return 0;  // si no funciono nada -> se ha alcanzado el limite de archivo
}

int cr_write(crFILE* file_desc, void* buffer, int nbytes){
    // printf("bytes rest: %d\n", nbytes);
    // printf("Pointer:    %p\n", &buffer);
    unsigned char *p =(unsigned char *) buffer;
    int written = 0;
    int size_f = 8;  // amount of bytes to be wroten in each iteration
    int bytes_rest = nbytes;  // bytes restantes

    if (!file_desc->mode){
        fprintf( stderr, "Error: operation not allowed\n");
        return 0;}
    
    if (block_written%2048==0){
        file_desc->p_pos = actualizar_bloque(file_desc);
    }
    if (!file_desc->p_pos){
        printf("Error: disk full you can't write more\n");
        return written; // no se puede seguir escribiendo
    }
    
    else{
        FILE* h = fopen(path_disk, "r+" );
        fseek( h, file_desc->p_pos, SEEK_SET );
        for (int i = 0; i < size_f; i++){
            // p[i];  // es un byte
            // ESCRIBIR los bytes en la posicion dada
            // printf("%c\n", ((char *) p) [i]);
            // printf("%x\n", p[i]);
            // printf("%u\n", p[i]);
            // printf("\n");
            
            fputc( (int) p[i], h);
            
            written++;
            block_written ++;
            bytes_rest --;
        }
        fclose(h);
        file_desc->p_pos = file_desc->p_pos+size_f; // actualizo el puntero
    }

    if (bytes_rest > 0){
        written += cr_write(file_desc, &p[written], bytes_rest);
    }

    // antes de devolver a written tengo que actualizar en bloque indice
    // los bytes escritos en sus bloques almacenados

    // ESCRIBIR los bytes escritos en el bloque indice

    // 4 Bytes al inicio del bloque para el tamaño del archivo.
    int inicio = (file_desc->p_index);
    // printf("DIR BLOQUE INDICE: %d\n",inicio);
    escribir_4byte_from_int(written, inicio);       
    // 81920
    return written;
}
////////////////////////////////////////////////////////////////////////////////
#include "file_mang_func.h"

extern char path_disk[400];

int global_written = 0;
int block_written  = 0; // indica cuantos he escrito en el
// bloque actual
int N_block =0;


const char *bit_rep_3[16] = {
    [ 0] = "0000", [ 1] = "0001", [ 2] = "0010", [ 3] = "0011",
    [ 4] = "0100", [ 5] = "0101", [ 6] = "0110", [ 7] = "0111",
    [ 8] = "1000", [ 9] = "1001", [10] = "1010", [11] = "1011",
    [12] = "1100", [13] = "1101", [14] = "1110", [15] = "1111",
};

char* byte4_str(uint32_t byte4){
    char* linea = malloc(sizeof(char)* 32);
    sprintf(linea,"%s%s%s%s%s%s%s%s",\
    bit_rep_3[(byte4 >> 28) & 0x0000000F],\
    bit_rep_3[(byte4 >> 24) & 0x0000000F],\
    bit_rep_3[(byte4 >> 20) & 0x0000000F],\
    bit_rep_3[(byte4 >> 16) & 0x0000000F],\
    bit_rep_3[(byte4 >> 12) & 0x0000000F],\
    bit_rep_3[(byte4 >> 8) & 0x0000000F],\
    bit_rep_3[(byte4 >> 4) & 0x0000000F],\
    bit_rep_3[byte4 & 0x0000000F]);
    // 0x0F = 0000 1111
    // 0x0000000F = 0000 0000 0000 0000 0000 0000 0000 1111
    return linea;
}

// stackOverflow
// https://stackoverflow.com/questions/36793073/how-to-convert-from-a-binary-string-to-binary-unsigned-char
unsigned char stringToBinary(char tmpSubjectStatus[]){
    int tmpInteger = 0;
    while (*tmpSubjectStatus)
    {
        tmpInteger <<= 1;
        if (*tmpSubjectStatus == '1')
            tmpInteger += 1;
        tmpSubjectStatus++;
    }
    return (unsigned char) tmpInteger;
}

void escribir_4byte_from_int_2(int indice_bloque, int where){
    // 100000000000101 = 16389 usa 7 bits
    // 0100000000000101 -> 2 bytes
    // 00000000 00000000 01000000 00000101 
    // 00000000 00000000 01000000 00000101
    // where = 4 * i
    FILE* h = fopen(path_disk, "r+" );    
    fseek( h, where, SEEK_SET ); 
    uint32_t b = (uint32_t) indice_bloque;
    // printf("EN uint32_t %u\n", b);
    // escribir 4 bytes
    char* linea = malloc(32*sizeof(char));
    linea = byte4_str(b);
    printf("TRANSFORMADO A BIN: %s\n", linea);
    
    char* linea1 = malloc(8*sizeof(char));
    char* linea2 = malloc(8*sizeof(char));
    char* linea3 = malloc(8*sizeof(char));
    char* linea4 = malloc(8*sizeof(char));

    sprintf(linea1, "%c%c%c%c%c%c%c%c", linea[0], linea[1], linea[2], linea[3], linea[4], linea[5], linea[6], linea[7]);
    sprintf(linea2, "%c%c%c%c%c%c%c%c", linea[8], linea[9], linea[10], linea[11], linea[12], linea[13], linea[14], linea[15]);
    sprintf(linea3, "%c%c%c%c%c%c%c%c", linea[16], linea[17], linea[18], linea[19], linea[20], linea[21], linea[22], linea[23]);
    sprintf(linea4, "%c%c%c%c%c%c%c%c", linea[24], linea[25], linea[26], linea[27], linea[28], linea[29], linea[30], linea[31]);

    // printf("LINEA1: %s\n", linea1); 
    // printf("LINEA2: %s\n", linea2); 
    // printf("LINEA3: %s\n", linea3); 
    // printf("LINEA4: %s\n", linea4);                 

    unsigned char byte1 = stringToBinary(linea1);
    unsigned char byte2 = stringToBinary(linea2);
    unsigned char byte3 = stringToBinary(linea3);
    unsigned char byte4 = stringToBinary(linea4);

    fputc( (int) byte1, h);
    fputc( (int) byte2, h);
    fputc( (int) byte3, h);
    fputc( (int) byte4, h);

    fclose(h);

    free(linea);   // STACK
    free(linea1);  // STACK	 
    free(linea2);  // STACK	 
    free(linea3);  // STACK	 
    free(linea4);  // STACK	 
}       

void escribir_4byte_from_int(int indice_bloque, int where){
    // 100000000000101 = 16389 usa 7 bits
    // 0100000000000101 -> 2 bytes
    // 00000000 00000000 01000000 00000101 
    // 00000000 00000000 01000000 00000101
    // where = 4 * i
    FILE* h = fopen(path_disk, "r+" );    
    fseek( h, where, SEEK_SET ); 
    uint32_t b = (uint32_t) indice_bloque;
    // printf("EN uint32_t %u\n", b); 
    // escribir 4 bytes
    char* linea = malloc(32*sizeof(char));
    linea = byte4_str(b);
    // printf("TRANSFORMADO A BIN: %s\n", linea);
    
    char* linea1 = malloc(8*sizeof(char));
    char* linea2 = malloc(8*sizeof(char));
    char* linea3 = malloc(8*sizeof(char));
    char* linea4 = malloc(8*sizeof(char));

    sprintf(linea1, "%c%c%c%c%c%c%c%c", linea[0], linea[1], linea[2], linea[3], linea[4], linea[5], linea[6], linea[7]);
    sprintf(linea2, "%c%c%c%c%c%c%c%c", linea[8], linea[9], linea[10], linea[11], linea[12], linea[13], linea[14], linea[15]);
    sprintf(linea3, "%c%c%c%c%c%c%c%c", linea[16], linea[17], linea[18], linea[19], linea[20], linea[21], linea[22], linea[23]);
    sprintf(linea4, "%c%c%c%c%c%c%c%c", linea[24], linea[25], linea[26], linea[27], linea[28], linea[29], linea[30], linea[31]);

    // printf("LINEA1: %s\n", linea1); 
    // printf("LINEA2: %s\n", linea2); 
    // printf("LINEA3: %s\n", linea3); 
    // printf("LINEA4: %s\n", linea4);                 

    unsigned char byte1 = stringToBinary(linea1);
    unsigned char byte2 = stringToBinary(linea2);
    unsigned char byte3 = stringToBinary(linea3);
    unsigned char byte4 = stringToBinary(linea4);

    fputc( (int) byte1, h);
    fputc( (int) byte2, h);
    fputc( (int) byte3, h);
    fputc( (int) byte4, h);

    fclose(h);

    free(linea);   // STACK
    free(linea1);  // STACK	 
    free(linea2);  // STACK	 
    free(linea3);  // STACK	 
    free(linea4);  // STACK	 
}       


int byte_pos(uint8_t byte){
    char linea[8];
    sprintf(linea, "%s%s", bit_rep_3[byte >> 4], bit_rep_3[byte & 0x0F]);

    for (int i = 0; i < 8; i++){
        if( linea[i] == '0'){
            return i;
        }
    }
    return 9;  // 9 marca que no encontro
}

char* change_bit_in_byte(uint8_t byte, int pos, char* linea){
    sprintf(linea, "%s%s", bit_rep_3[byte >> 4], bit_rep_3[byte & 0x0F]);
    linea[pos] = '1';
    return linea;
}

uint32_t transform_8buffer_32(uint8_t a1,uint8_t a2, uint8_t a3, uint8_t a4){

}

int search_free_space(){
    // busca un bloque libre para transformarlo en uno de datos
    // tengo que actualizar el bitmap cuando creo
    // el bloque de datos
    FILE* f = fopen(path_disk, "rb" );
	unsigned char *buffer = malloc( sizeof(unsigned char) * 8 );
    // buffer de 8 Byte
	for( int i = 256; i < 1280; i++ ) {    
		fseek( f, 8 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 8, f );
        for (int j = 0; j < 8; j++){
            uint8_t b = (uint8_t) buffer[j];
            // tenemos 1 bytes es decir 8 bits
            // necesitamos saber si en esos 8 bits hay un 0
            // y si lo hay donde y cambiarlo por 1
            int pos = byte_pos(b);
            if (pos<9){
                fclose(f);
                // 256*8 = 2048 Bytes * 8 = bits

                // ESCRIBIR actualizar bitmap

                // FILE* h = fopen(path_disk, "wb" );
                // FILE* h = fopen(path_disk, "w+" );
                FILE* h = fopen(path_disk, "r+" );
                int posicion = 8*i+j;

                char* linea = malloc(8*sizeof(char));
                linea = change_bit_in_byte(b, pos, linea);
                unsigned char imp = stringToBinary(linea);

                // printf("VIEJA LINEA: %u\n", buffer[j]);
                // printf("NUEVA LINEA: %s\n", linea);
                // printf("NUEVA LINEA TRANSFORMADA: %u\n", imp);

                printf("POSICION %d\n", posicion);
                // MUERE AQUI OJO
                fseek( h, posicion, SEEK_SET );
                fputc( (int) imp, h);
                
                fclose(h);
                // NO HACE EL PRINT BINARY
                print_binary(2048/8, (2048+128)/8);
                
                // int indice_bloque = ((posicion*2048) + pos);
                // int indice_bloque = (((((i-256)*8)+j)*2048)+pos);
                // int indice_bloque = (((((i-256)*8)+j+pos)*2048));

                // printf("i:   %d\n",i);
                // printf("j:   %d\n",j);
                // printf("pos: %d\n",pos);
                int indice_bloque = (((((i-256+j)*8)+pos)*2048));
                
                free(linea); // STACK
                free(buffer);
                
                return indice_bloque; // pos en bits  
                }
            }
        }
    return 0;
}

int actualizar_bloque(crFILE* file_desc){
    // se encarga de decirme donde hay un bloque para escribir
    // actualiza la info del index block
    // si no quedan bloques retorna 0

    // cada puntero es de 4 bytes
    FILE* f = fopen(path_disk, "rb" );    
	unsigned char *buffer = malloc( sizeof(unsigned char) * 4 );

    // buscamos un espacio para direccionar dentro del bloque indice
    // 2000 bytes
    int inicio = (file_desc->p_index/4) + 2;
    // leo del bloque indice la parte de direccionamiento directo
	for( int i = inicio; i < inicio + 500; i++ ) {
		fseek( f, 4 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 4, f );

        int es_cero = 1;
        for (int j = 0; j < 4; j++){
            uint8_t c = (uint8_t) buffer[j];
            if (c){
                es_cero=0;
            }
        }


        if (es_cero){
            printf("Hay espacio en direccionamiento directo\n");
            // debo buscar un bloque libre para que sea
            // el bloque de datos
            // printf("MURIO EN EL SEARCH\n");
            int indice_bloque = search_free_space();
            // printf("NO MURIO EN EL SEARCH\n");
            // en cr_write nos ocuparemos de actualizar los
            // bytes escritos en el bloque indice
            if (indice_bloque){
                printf("Hay espacio nuevo bloque de datos [%d]\n", 4 * i);    
                fclose(f);
                // ESCRIBIR el puntero a la dir encontrada en la parte de
                // direccionamiento directo
                escribir_4byte_from_int_2(indice_bloque, 4*i);

                // prints para ver que sucede
                printf("numero Bloque escrito: %d\n", N_block);
                printf("Indice Bloque: %d\n", indice_bloque);                
                // print_binary(((2048*40)-32)/8, ((2048*40)+150)/8);
                print_binary(((4*i)-32)/8, ((i*4)+150)/8);
                printf("I: %d\n", i*4);

                free(buffer); // STACK                             
                return indice_bloque;
            }
        }
    };
    
    // 40 bytes de punteros a bloques de dir indirecto
    printf("probando con indirecto\n");
    for( int i = inicio + 502; i < inicio + 512; i++ ) { 
		fseek( f, 4 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 4, f );

        int es_cero = 1;
        for (int j = 0; j < 4; j++){
            uint8_t c = (uint8_t) buffer[j];
            if (c){
                es_cero=0;
            }
        }

        // uint32_t b = (uint32_t) *buffer; // 4 * 8 = 32
        // este b probablemente falle
        // pero es momentaneo
        uint32_t b = transform_8buffer_32(buffer[0],buffer[1],buffer[2],buffer[3]);
        
        if (!es_cero){
            printf("buscando espacio dentro de bloque de direccionamiento indirecto\n");
            // si entre -> b es un puntero a un bloque de dir indirecto
            // debo revisar si este bloque tiene espacio para otro puntero
            // a un bloque de datos
            for( int j = (int) b; j < ((int)b) + 512; j++ ) {    
                fseek( f, 4 * j, SEEK_SET );
		        fread( buffer, sizeof( unsigned char ), 4, f );

                int es_cero_2 = 1;
                for (int j = 0; j < 4; j++){
                    uint8_t c = (uint8_t) buffer[j];
                    if (c){
                        es_cero_2=0;
                    }
                }

                if (es_cero_2){
                    printf("hay espacio en este bloque de dir. indirecto\n");
                    // hay espacio para otro puntero de datos
                    int indice_bloque = search_free_space();
                    if (indice_bloque){
                        printf("hay espacio para nuevo bloque de datos\n");
                        // si encontre un lugar para un bloque de datos
                        // ESCRIBIR el puntero a la dir encontrada en el bloque
                        // de direccionamiento indirecto
                        printf("Indice Bloque: %d\n", indice_bloque);
                        fclose(f);
                        escribir_4byte_from_int(indice_bloque, 4*j);     
                        return indice_bloque;
                    }
                }
            }
        }
        
        else{
            printf("Hay espacio para nuevo puntero a un bloque de direccionamiento indirecto\n");
            //ahora debemos buscar un espacio vacio para 
            //un bloque de dir indirecto guardar su direccion
            //luego buscar un espacio vacio para un bloque de datos que va a 
            //guardar su direccion en el nuevo bloque de dir indirecto
            int indice_bloque_indirect = search_free_space();
            // ESCRIBIR el puntero a la dir encontrada en la parte
            // de direccionamiento indirecto
            if (indice_bloque_indirect){
                printf("Hay espacio para nuevo bloque\n");
                for( int j = indice_bloque_indirect; j<indice_bloque_indirect\
                 +512; j++ ) {    
                    fseek( f, 4 * j, SEEK_SET );
                    fread( buffer, sizeof( unsigned char ), 4, f );
                    
                    int es_cero_3 = 1;
                    for (int j = 0; j < 4; j++){
                        uint8_t c = (uint8_t) buffer[j];
                        if (c){
                            es_cero_3=0;
                        }
                    }

                    if (es_cero_3){
                        printf("Hay espacio para nuevo puntero a datos\n");
                        // espacio para otro puntero de datos
                        int indice_bloque = search_free_space();
                        if (indice_bloque){
                            printf("Hay espacio para nuevo bloque de datos\n");
                            // si encontre un lugar para un bloque de datos
                            // ESCRIBIR el puntero a la dir encontrada en el bloque
                            // de direccionamiento indirecto
                            printf("Indice Bloque: %d\n", indice_bloque);
                            fclose(f);
                            escribir_4byte_from_int(indice_bloque, 4*j);       
                            return indice_bloque;
                        }
                    }
                }
            }
        }
	};
    
    fclose(f);
	free( buffer );
    return 0;  // si no funciono nada -> se ha alcanzado el limite de archivo
}

int cr_write(crFILE* file_desc, void* buffer, int nbytes){
    // printf("bytes rest: %d\n", nbytes);
    // printf("Pointer:    %p\n", &buffer);
    unsigned char *p =(unsigned char *) buffer;
    int written = 0;
    int size_f = 8;  // amount of bytes to be wroten in each iteration
    int bytes_rest = nbytes;  // bytes restantes

    if (!file_desc->mode){
        fprintf( stderr, "Error: operation not allowed\n");
        return 0;}
    
    if (block_written%2048==0){
        N_block ++;
        // printf("MURIO AQUI [block_written %d]\n",block_written);
        file_desc->p_pos = actualizar_bloque(file_desc);
        // printf("NO MURIO AQUI\n");
    }
    if (!file_desc->p_pos){
        printf("Error: disk full you can't write more\n");
        return written; // no se puede seguir escribiendo
    }
    
    else{
        // printf("MURIO AQUI 1\n");
        FILE* h = fopen(path_disk, "r+" );
        // printf("MURIO AQUI 2\n");
        fseek( h, file_desc->p_pos, SEEK_SET );
        // printf("MURIO AQUI 3\n");
        for (int i = 0; i < size_f; i++){
            // p[i];  // es un byte
            // ESCRIBIR los bytes en la posicion dada
            // printf("%c\n", ((char *) p) [i]);
            // printf("%x\n", p[i]);
            // printf("%u\n", p[i]);
            // printf("\n");
            
            fputc( (int) p[i], h);
            
            written++;
            block_written ++;
            bytes_rest --;
        }
        // printf("MURIO AQUI 4\n");
        fclose(h);
        // printf("MURIO AQUI 5\n");
        file_desc->p_pos = file_desc->p_pos+size_f; // actualizo el puntero
        // printf("MURIO AQUI 6 [%d]{%d}\n",file_desc->p_pos, bytes_rest);
    }

    if (bytes_rest > 0){
        // MUERE PORQUE ESTO SE LLAMA MUCHAS VECES OJO
        written += cr_write(file_desc, &p[written], bytes_rest);
    }

    // antes de devolver a written tengo que actualizar en bloque indice
    // los bytes escritos en sus bloques almacenados

    // ESCRIBIR los bytes escritos en el bloque indice

    // 4 Bytes al inicio del bloque para el tamaño del archivo.
    int inicio = (file_desc->p_index);
    // printf("DIR BLOQUE INDICE: %d\n",inicio);
    escribir_4byte_from_int(written, inicio);       
    // 81920
    return written;
}

ver final con prints
#include "file_mang_func.h"

extern char path_disk[400];

int global_written = 0;
int block_written  = 0; // indica cuantos he escrito en el
// bloque actual
int N_block =0;

int num_bloques_dir_ind = 0;
int num_bloques_datos   = 0;

const char *bit_rep_3[16] = {
    [ 0] = "0000", [ 1] = "0001", [ 2] = "0010", [ 3] = "0011",
    [ 4] = "0100", [ 5] = "0101", [ 6] = "0110", [ 7] = "0111",
    [ 8] = "1000", [ 9] = "1001", [10] = "1010", [11] = "1011",
    [12] = "1100", [13] = "1101", [14] = "1110", [15] = "1111",
};

char* byte4_str(uint32_t byte4){
    char* linea = malloc(sizeof(char)* 32);
    sprintf(linea,"%s%s%s%s%s%s%s%s",\
    bit_rep_3[(byte4 >> 28) & 0x0000000F],\
    bit_rep_3[(byte4 >> 24) & 0x0000000F],\
    bit_rep_3[(byte4 >> 20) & 0x0000000F],\
    bit_rep_3[(byte4 >> 16) & 0x0000000F],\
    bit_rep_3[(byte4 >> 12) & 0x0000000F],\
    bit_rep_3[(byte4 >> 8) & 0x0000000F],\
    bit_rep_3[(byte4 >> 4) & 0x0000000F],\
    bit_rep_3[byte4 & 0x0000000F]);
    // 0x0F = 0000 1111
    // 0x0000000F = 0000 0000 0000 0000 0000 0000 0000 1111
    return linea;
}

// stackOverflow
// https://stackoverflow.com/questions/36793073/how-to-convert-from-a-binary-string-to-binary-unsigned-char
unsigned char stringToBinary(char tmpSubjectStatus[]){
    int tmpInteger = 0;
    while (*tmpSubjectStatus)
    {
        tmpInteger <<= 1;
        if (*tmpSubjectStatus == '1')
            tmpInteger += 1;
        tmpSubjectStatus++;
    }
    return (unsigned char) tmpInteger;
}

void escribir_4byte_from_int_2(int indice_bloque, int where){
    // 100000000000101 = 16389 usa 7 bits
    // 0100000000000101 -> 2 bytes
    // 00000000 00000000 01000000 00000101 
    // 00000000 00000000 01000000 00000101
    // where = 4 * i
    FILE* h = fopen(path_disk, "r+" );    
    fseek( h, where, SEEK_SET ); 
    uint32_t b = (uint32_t) indice_bloque;
    // printf("EN uint32_t %u\n", b);
    // escribir 4 bytes
    char* linea = malloc(32*sizeof(char));
    linea = byte4_str(b);
    // printf("TRANSFORMADO A BIN: %s\n", linea);
    
    char* linea1 = malloc(8*sizeof(char));
    char* linea2 = malloc(8*sizeof(char));
    char* linea3 = malloc(8*sizeof(char));
    char* linea4 = malloc(8*sizeof(char));

    sprintf(linea1, "%c%c%c%c%c%c%c%c", linea[0], linea[1], linea[2], linea[3], linea[4], linea[5], linea[6], linea[7]);
    sprintf(linea2, "%c%c%c%c%c%c%c%c", linea[8], linea[9], linea[10], linea[11], linea[12], linea[13], linea[14], linea[15]);
    sprintf(linea3, "%c%c%c%c%c%c%c%c", linea[16], linea[17], linea[18], linea[19], linea[20], linea[21], linea[22], linea[23]);
    sprintf(linea4, "%c%c%c%c%c%c%c%c", linea[24], linea[25], linea[26], linea[27], linea[28], linea[29], linea[30], linea[31]);

    // printf("LINEA1: %s\n", linea1); 
    // printf("LINEA2: %s\n", linea2); 
    // printf("LINEA3: %s\n", linea3); 
    // printf("LINEA4: %s\n", linea4);                 

    unsigned char byte1 = stringToBinary(linea1);
    unsigned char byte2 = stringToBinary(linea2);
    unsigned char byte3 = stringToBinary(linea3);
    unsigned char byte4 = stringToBinary(linea4);

    fputc( (int) byte1, h);
    fputc( (int) byte2, h);
    fputc( (int) byte3, h);
    fputc( (int) byte4, h);

    fclose(h);

    free(linea);   // STACK
    free(linea1);  // STACK	 
    free(linea2);  // STACK	 
    free(linea3);  // STACK	 
    free(linea4);  // STACK	 
}       

void escribir_4byte_from_int(int indice_bloque, int where){
    // 100000000000101 = 16389 usa 7 bits
    // 0100000000000101 -> 2 bytes
    // 00000000 00000000 01000000 00000101 
    // 00000000 00000000 01000000 00000101
    // where = 4 * i
    FILE* h = fopen(path_disk, "r+" );    
    fseek( h, where, SEEK_SET ); 
    uint32_t b = (uint32_t) indice_bloque;
    // printf("EN uint32_t %u\n", b); 
    // escribir 4 bytes
    char* linea = malloc(32*sizeof(char));
    linea = byte4_str(b);
    printf("TRANSFORMADO A BIN: %s\n", linea);
    
    char* linea1 = malloc(8*sizeof(char));
    char* linea2 = malloc(8*sizeof(char));
    char* linea3 = malloc(8*sizeof(char));
    char* linea4 = malloc(8*sizeof(char));

    sprintf(linea1, "%c%c%c%c%c%c%c%c", linea[0], linea[1], linea[2], linea[3], linea[4], linea[5], linea[6], linea[7]);
    sprintf(linea2, "%c%c%c%c%c%c%c%c", linea[8], linea[9], linea[10], linea[11], linea[12], linea[13], linea[14], linea[15]);
    sprintf(linea3, "%c%c%c%c%c%c%c%c", linea[16], linea[17], linea[18], linea[19], linea[20], linea[21], linea[22], linea[23]);
    sprintf(linea4, "%c%c%c%c%c%c%c%c", linea[24], linea[25], linea[26], linea[27], linea[28], linea[29], linea[30], linea[31]);

    // printf("LINEA1: %s\n", linea1); 
    // printf("LINEA2: %s\n", linea2); 
    // printf("LINEA3: %s\n", linea3); 
    // printf("LINEA4: %s\n", linea4);                 

    unsigned char byte1 = stringToBinary(linea1);
    unsigned char byte2 = stringToBinary(linea2);
    unsigned char byte3 = stringToBinary(linea3);
    unsigned char byte4 = stringToBinary(linea4);

    fputc( (int) byte1, h);
    fputc( (int) byte2, h);
    fputc( (int) byte3, h);
    fputc( (int) byte4, h);

    fclose(h);

    free(linea);   // STACK
    free(linea1);  // STACK	 
    free(linea2);  // STACK	 
    free(linea3);  // STACK	 
    free(linea4);  // STACK	 
}       


int byte_pos(uint8_t byte){
    char linea[8];
    sprintf(linea, "%s%s", bit_rep_3[byte >> 4], bit_rep_3[byte & 0x0F]);

    for (int i = 0; i < 8; i++){
        if( linea[i] == '0'){
            return i;
        }
    }
    return 9;  // 9 marca que no encontro
}

char* change_bit_in_byte(uint8_t byte, int pos, char* linea){
    sprintf(linea, "%s%s", bit_rep_3[byte >> 4], bit_rep_3[byte & 0x0F]);
    linea[pos] = '1';
    return linea;
}

uint32_t transform_8buffer_32(uint8_t a1,uint8_t a2, uint8_t a3, uint8_t a4){
    // EIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTEIMPORTANTE [8913664], [0]
    // uint32_t i32 = a1 | (a2 << 8) | (a3 << 16) | (a4 << 24);

    // o es esta la correcta

    uint32_t i32 = a4 | (a3 << 8) | (a2 << 16) | (a1 << 24);
    return i32;
}

int search_free_space(){
    // busca un bloque libre para transformarlo en uno de datos
    // tengo que actualizar el bitmap cuando creo
    // el bloque de datos
    FILE* f = fopen(path_disk, "rb" );
	unsigned char *buffer = malloc( sizeof(unsigned char) * 8 );
    // buffer de 8 Byte
	for( int i = 256; i < 1280; i++ ) {    
		fseek( f, 8 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 8, f );
        for (int j = 0; j < 8; j++){
            uint8_t b = (uint8_t) buffer[j];
            // tenemos 1 bytes es decir 8 bits
            // necesitamos saber si en esos 8 bits hay un 0
            // y si lo hay donde y cambiarlo por 1
            int pos = byte_pos(b);
            if (pos<9){
                fclose(f);
                // 256*8 = 2048 Bytes * 8 = bits

                // ESCRIBIR actualizar bitmap

                // FILE* h = fopen(path_disk, "wb" );
                // FILE* h = fopen(path_disk, "w+" );
                FILE* h = fopen(path_disk, "r+" );
                int posicion = 8*i+j;

                char* linea = malloc(8*sizeof(char));
                linea = change_bit_in_byte(b, pos, linea);
                unsigned char imp = stringToBinary(linea);

                // printf("VIEJA LINEA: %u\n", buffer[j]);
                // printf("NUEVA LINEA: %s\n", linea);
                // printf("NUEVA LINEA TRANSFORMADA: %u\n", imp);

                printf("POSICION %d\n", posicion);
                // MUERE AQUI OJO
                fseek( h, posicion, SEEK_SET );
                fputc( (int) imp, h);
                
                fclose(h);
                
                // print_binary(2048/8, (2048+128)/8);
                
                // int indice_bloque = ((posicion*2048) + pos);
                // int indice_bloque = (((((i-256)*8)+j)*2048)+pos);
                // int indice_bloque = (((((i-256)*8)+j+pos)*2048));

                // printf("i:   %d\n",i);
                // printf("j:   %d\n",j);
                // printf("pos: %d\n",pos);
                int indice_bloque = (((((i-256+j)*8)+pos)*2048));
                
                free(linea); // STACK
                free(buffer);
                
                return indice_bloque; // pos en bits  
                }
            }
        }
    return 0;
}

int actualizar_bloque(crFILE* file_desc){
    // se encarga de decirme donde hay un bloque para escribir
    // actualiza la info del index block
    // si no quedan bloques retorna 0

    // cada puntero es de 4 bytes
    FILE* f = fopen(path_disk, "rb" );    
	unsigned char *buffer = malloc( sizeof(unsigned char) * 4 );

    // buscamos un espacio para direccionar dentro del bloque indice
    // 2000 bytes
    int inicio = (file_desc->p_index/4) + 2;
    // leo del bloque indice la parte de direccionamiento directo
	for( int i = inicio; i < inicio + 500; i++ ) {
		fseek( f, 4 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 4, f );

        int es_cero = 1;
        for (int j = 0; j < 4; j++){
            uint8_t c = (uint8_t) buffer[j];
            if (c){
                es_cero=0;
            }
        }


        if (es_cero){
            printf("Hay espacio en direccionamiento directo\n");
            // debo buscar un bloque libre para que sea
            // el bloque de datos
            // printf("MURIO EN EL SEARCH\n");
            int indice_bloque = search_free_space();
            // printf("NO MURIO EN EL SEARCH\n");
            // en cr_write nos ocuparemos de actualizar los
            // bytes escritos en el bloque indice
            if (indice_bloque){
                printf("Hay espacio nuevo bloque de datos [%d]\n", 4 * i);    
                fclose(f);
                num_bloques_datos++;
                // ESCRIBIR el puntero a la dir encontrada en la parte de
                // direccionamiento directo
                escribir_4byte_from_int_2(indice_bloque, 4*i);

                // prints para ver que sucede
                printf("numero Bloque escrito: %d\n", N_block);
                printf("Indice Bloque: %d\n", indice_bloque);                
                // print_binary(((2048*40)-32)/8, ((2048*40)+150)/8);
                // print_binary(((4*i)-32)/8, ((i*4)+150)/8);
                printf("I: %d\n", i*4);

                free(buffer); // STACK                             
                return indice_bloque;
            }
        }
    };
    
    // 40 bytes de punteros a bloques de dir indirecto
    printf("probando con indirecto\n");
    // for( int i = inicio + 502; i < inicio + 512; i++ ) {
    for( int i = inicio + 500; i < inicio + 510; i++ ) { 

		fseek( f, 4 * i, SEEK_SET );
		fread( buffer, sizeof( unsigned char ), 4, f );

        int es_cero = 1;
        for (int j = 0; j < 4; j++){
            uint8_t c = (uint8_t) buffer[j];
            if (c){
                es_cero=0;
            }
        }
        uint32_t b = transform_8buffer_32((uint8_t)buffer[0], (uint8_t)buffer[1],(uint8_t)buffer[2], (uint8_t)buffer[3]);

        // print_binary(((4*i)-32)/8, ((i*4)+150)/8);

        if (!es_cero){ // si encuentro un puntero a un bloque de dir. indirecto
            printf("buscando espacio dentro de bloque de direccionamiento indirecto\n");
            // si entre -> b es un puntero a un bloque de dir indirecto
            // debo revisar si este bloque tiene espacio para otro puntero
            // a un bloque de datos
            for( int j = (int) b; j < ((int)b) + 512; j++ ) {    
                fseek( f, 4 * j, SEEK_SET );
		        fread( buffer, sizeof( unsigned char ), 4, f );

                int es_cero_2 = 1;
                for (int j = 0; j < 4; j++){
                    uint8_t c = (uint8_t) buffer[j];
                    if (c){
                        es_cero_2=0;
                    }
                }

                if (es_cero_2){
                    printf("hay espacio en este bloque de dir. indirecto\n");
                    // hay espacio para otro puntero de datos
                    int indice_bloque = search_free_space();
                    if (indice_bloque){
                        printf("hay espacio para nuevo bloque de datos\n");
                        num_bloques_datos++;
                        // si encontre un lugar para un bloque de datos
                        // ESCRIBIR el puntero a la dir encontrada en el bloque
                        // de direccionamiento indirecto
                        printf("Indice Bloque: %d\n", indice_bloque);
                        fclose(f);
                        escribir_4byte_from_int(indice_bloque, 4*j);     
                        return indice_bloque;
                    }
                }
            }
        }
        
        else{ // si buscando me encuentro uno vacio
            // quiere decir que los anteriores estaban llenos
            printf("Hay espacio para nuevo puntero a un bloque de direccionamiento indirecto\n");
            //ahora debemos buscar un espacio vacio para 
            //un bloque de dir indirecto guardar su direccion
            //luego buscar un espacio vacio para un bloque de datos que va a 
            //guardar su direccion en el nuevo bloque de dir indirecto
            int indice_bloque_indirect = search_free_space();
            // ESCRIBIR el puntero a la dir encontrada en la parte
            // de direccionamiento indirecto
            if (indice_bloque_indirect){
                printf("Hay espacio para nuevo bloque\n");

                // debo escribir esta direccion en el bloque indice
                escribir_4byte_from_int_2(indice_bloque_indirect, 4*i);
                num_bloques_dir_ind ++;

                for( int j = indice_bloque_indirect; j<indice_bloque_indirect\
                 +512; j++ ) {    
                    fseek( f, 4 * j, SEEK_SET );
                    fread( buffer, sizeof( unsigned char ), 4, f );
                    
                    int es_cero_3 = 1;
                    for (int j = 0; j < 4; j++){
                        uint8_t c = (uint8_t) buffer[j];
                        if (c){
                            es_cero_3=0;
                        }
                    }
                    // No parece ser realmente necesario revisar si esta vacio
                    // si lo acabo de crear pero de igual manera lo dejo

                    if (es_cero_3){
                        printf("Hay espacio para nuevo puntero a datos\n");
                        // espacio para otro puntero de datos
                        int indice_bloque = search_free_space();
                        if (indice_bloque){
                            printf("Hay espacio para nuevo bloque de datos\n");
                            num_bloques_datos++;
                            // si encontre un lugar para un bloque de datos
                            // ESCRIBIR el puntero a la dir encontrada en el bloque
                            // de direccionamiento indirecto
                            printf("Indice Bloque: %d\n", indice_bloque);
                            fclose(f);
                            escribir_4byte_from_int(indice_bloque, 4*j);       
                            return indice_bloque;
                        }
                    }
                }
            }
        }
	};
    
    fclose(f);
	free( buffer );
    return 0;  // si no funciono nada -> se ha alcanzado el limite de archivo
}

int cr_write(crFILE* file_desc, void* buffer, int nbytes){
    // printf("bytes rest: %d\n", nbytes);
    // printf("Pointer:    %p\n", &buffer);
    unsigned char *p =(unsigned char *) buffer;
    int written = 0;
    int size_f = 8;  // amount of bytes to be wroten in each iteration
    int bytes_rest = nbytes;  // bytes restantes

    if (!file_desc->mode){
        fprintf( stderr, "Error: operation not allowed\n");
        return 0;}
    
    if (block_written%2048==0){
        N_block ++;
        // printf("MURIO AQUI [block_written %d]\n",block_written);
        file_desc->p_pos = actualizar_bloque(file_desc);
        // printf("NO MURIO AQUI\n");
    }
    if (!file_desc->p_pos){
        printf("Error: disk full you can't write more\n");
        return written; // no se puede seguir escribiendo
    }
    
    else{
        // printf("MURIO AQUI 1\n");
        FILE* h = fopen(path_disk, "r+" );
        // printf("MURIO AQUI 2\n");
        fseek( h, file_desc->p_pos, SEEK_SET );
        // printf("MURIO AQUI 3\n");
        for (int i = 0; i < size_f; i++){
            // p[i];  // es un byte
            // ESCRIBIR los bytes en la posicion dada
            // printf("%c\n", ((char *) p) [i]);
            // printf("%x\n", p[i]);
            // printf("%u\n", p[i]);
            // printf("\n");
            
            fputc( (int) p[i], h);
            
            written++;
            block_written ++;
            bytes_rest --;
        }
        // printf("MURIO AQUI 4\n");
        fclose(h);
        // printf("MURIO AQUI 5\n");
        file_desc->p_pos = file_desc->p_pos+size_f; // actualizo el puntero
        // printf("MURIO AQUI 6 [%d]{%d}\n",file_desc->p_pos, bytes_rest);
    }

    if (bytes_rest > 0){
        // MUERE PORQUE ESTO SE LLAMA MUCHAS VECES OJO
        written += cr_write(file_desc, &p[written], bytes_rest);
    }

    // antes de devolver a written tengo que actualizar en bloque indice
    // los bytes escritos en sus bloques almacenados

    // ESCRIBIR los bytes escritos en el bloque indice

    // 4 Bytes al inicio del bloque para el tamaño del archivo.
    int inicio = (file_desc->p_index);
    // printf("DIR BLOQUE INDICE: %d\n",inicio);
    escribir_4byte_from_int(written, inicio);       
    // 81920
    // printf("NUM. Bloques[datos] escritos: %d\nNUM. Bloques dir ind. usados: %d\n", num_bloques_datos, num_bloques_dir_ind);
    return written;
}

*/
